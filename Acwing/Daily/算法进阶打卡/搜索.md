## Flood Fill

​	Flood Fill（泛洪填充）：从一个起始节点开始，把附近与其连通的节点提取出或填充成不同颜色，直到封闭区域内的所有节点都被处理过为止。
是从一个区域中提取若干个连通的点与其他相邻区域区分开(或分别染成不同颜色)的经典算法。

​	可以抽象成一个二维矩阵（图片其实就是像素点矩阵），然后从某个点开始向四周扩展，直到无法再扩展为止。

​	即求连通块问题的算法。
​	
​	具体实现采用BFS或DFS。

​	BFS求解：可以求出最短路或者判断两者是否连通，不存在爆栈的风险，但空间相对用的多一些而且代码相对来说繁琐一些。

​	DFS求解：DFS代码简洁，相对好写一些，但存在爆栈的风险，而且不能求出最短路。
​	(网上查的资料)





### 池塘记数

#### 题目





#### 思路

经典的bfs问题

线性的复杂度,每个点最多被找两遍



#### 代码

```c++
队列实现dfs

#include <bits/stdc++.h>
using namespace std;

int dir[8][2] = {1, 0, 0, 1, -1, 0, 0, -1, 1, 1, 1, -1, -1, 1, -1, -1};
const int N = 1e3 + 10;
char c[N][N];
int res = 0;
int n, m;
queue<pair<int, int>> q;
void bfs(int x, int y)
{

     q.push({x, y});
     c[x][y] = '.';
     while (q.size())
     {

          int sx = q.front().first, sy = q.front().second;
          q.pop();
          c[sx][sy] = '.';

          for (int i = 0; i < 8; i++)
          {
               int nx = sx + dir[i][0];
               int ny = sy + dir[i][1];

               if (nx < 0 || nx >= n || ny < 0 || ny >= m)
                    continue;
               if (c[nx][ny] == '.')
                    continue;

               q.push({nx, ny});
               c[nx][ny] = '.';//在这就要把它变为点,这步不能不要
          }
     }
     res++;
}

int main()
{

     cin >> n >> m;

     for (int i = 0; i < n; i++)
          for (int j = 0; j < m; j++)
          {
               cin >> c[i][j];
          }

     for (int i = 0; i < n; i++)
          for (int j = 0; j < m; j++)
          {
               if (c[i][j] == 'W')
               {
                    bfs(i, j);
               }
          }

     cout << res << endl;
}
```



```c++
手写队列

#include <bits/stdc++.h>
using namespace std;
#define x first
#define y second
int dir[8][2] = {1, 0, 0, 1, -1, 0, 0, -1, 1, 1, 1, -1, -1, 1, -1, -1};
const int N = 1e3 + 10;
const int M = 1e6 + 10;
char c[N][N];
int res = 0;
int n, m;
typedef pair<int, int> PII;
PII q[M];
void bfs(int sx, int sy)
{
     int hh = 0, tt = 0;
     q[0] = {sx, sy};
     c[sx][sy] = '.';

     while (hh <= tt)
     {
          PII t = q[hh++];

          for (int i = 0; i < 8; i++)
          {
               int nx = t.x + dir[i][0];
               int ny = t.y + dir[i][1];

               if (nx < 0 || nx >= n || ny < 0 || ny >= m)
                    continue;
               if (c[nx][ny] == '.')
                    continue;

               q[++tt] = {nx, ny};
               c[nx][ny] = '.';
          }
     }
}

int main()
{

     cin >> n >> m;

     for (int i = 0; i < n; i++)
          for (int j = 0; j < m; j++)
          {
               cin >> c[i][j];
          }

     for (int i = 0; i < n; i++)
          for (int j = 0; j < m; j++)
          {
               if (c[i][j] == 'W')
               {
                    bfs(i, j);
                    res++;
               }
          }
     cout << res;
}
```











### 城堡问题



#### 题目



#### 思路

稍微改了样子的经典bfs.(巧妙的bfs)

本来想着,输入的每个数字都是唯一的(如11就代表着它有着西北南三面墙),从而能在bfs的for循环里,判断下一个走的数字能不能从现在的位置走到,如第二行第一个的数字7,想往上走,发现是11,就知道了它南面有墙,走不到,直接continue.

但是写的时候,意识到想要实现这个思路,就必须要先讨论一遍所有可能出现的数字(11,6,3,10…),太多情况了,写起来会很冗余.

以下高能!(卡在这了 orz)

我们发现它墙是由1,2,4,8来表示的,刚好符合二进制的规则.所以我们直接用位运算就可以判断出这个数字是哪几面墙组成.(如11=>1011,只要这一位是0,代表这一位代表的方位没有墙.)

更巧妙的是,每一个数字都要经过4次位移,这刚好可以和bfs四次for循环判断方位结合起来



<!--对1,2,4,8这类数要敏感-->

#### 代码

```c++

#include <bits/stdc++.h>
using namespace std;
const int N = 55;
int dir[4][2] = {0, 1, 1, 0, 0, -1, -1, 0};
int g[N][N];
int st[N][N];
int n, m;
int area;
void bfs(int sx, int sy)
{
     queue<pair<int, int>> q;
     q.push({sx, sy});
     st[sx][sy] = 1;
     area = 0;
     while (q.size())
     {
          auto t = q.front();
          q.pop();
          area++;
          for (int i = 0; i < 4; i++)
          {
               int nx = t.first + dir[i][0];
               int ny = t.second + dir[i][1];
               if (nx < 0 || nx >= n || ny < 0 || ny >= m)
                    continue;
               if (st[nx][ny])
                    continue;
               if (g[nx][ny] >> i & 1)
                    continue;
                    //假如i=0,我们把dir[0][0/1]对应的方位设置为让现在这个点往东走,而如果这个数字二进制第0位是1的话,代表我们想去的点西面有墙,我们过不去,continue!
                   
               q.push({nx, ny});
               st[nx][ny] = 1;
          }
     }
}
int main()
{
     cin >> n >> m;
     for (int i = 0; i < n; i++)
          for (int j = 0; j < m; j++)
               cin >> g[i][j];
     int ans = 0;
     int num = 0;
     for (int i = 0; i < n; i++)
          for (int j = 0; j < m; j++)
          {
               if (!st[i][j])
               {
                    bfs(i, j);
                    ans = max(ans, area);
                    num++;
               }
          }
     cout << num << endl
          << ans;
}
```





### 山峰和山谷



#### 题目





#### 思路

经典bfs的变形



#### 代码

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1e3 + 10;
int dir[8][2] = {1, 0, 0, 1, -1, 0, 0, -1, 1, 1, 1, -1, -1, 1, -1, -1};
int g[N][N];
int st[N][N];
int n;
int num1 = 0, num2 = 0;

void bfs(int sx, int sy)
{

     queue<pair<int, int>> q;
     q.push({sx, sy});
     st[sx][sy] = 1;
     int f = 0;
     int f1 = 0;
     while (q.size())
     {
          auto t = q.front();

          q.pop();
          for (int i = 0; i < 8; i++)
          {
               int nx = t.first + dir[i][0];
               int ny = t.second + dir[i][1];

               if (nx < 0 || nx >= n || ny < 0 || ny >= n)
                    continue;

               if (g[nx][ny] != g[sx][sy])
               {
                    if (g[nx][ny] < g[sx][sy])
                    {
                         if (f == 2)
                              f1 = 1;
                         f = 1;
                    }
                    else
                    {
                         if (f == 1)
                              f1 = 1;
                         f = 2;
                    }
                    continue;
               }
               if (st[nx][ny])
                    continue;
               q.push({nx, ny});
               st[nx][ny] = 1;
          }
     }
     if (f1)
          return;
     if (f == 1)
          num1++;

     else if (f == 2)
          num2++;

     else if (f == 0)
          num1++, num2++;
}

int main()
{

     cin >> n;

     for (int i = 0; i < n; i++)
          for (int j = 0; j < n; j++)
               cin >> g[i][j];

     for (int i = 0; i < n; i++)
          for (int j = 0; j < n; j++)
          {
               if (!st[i][j])
                    bfs(i, j);
                    }
     cout << num1 << ' ' << num2;
}
```













## 最短路问题



### 迷宫问题

#### 题目





#### 思路

简单的bfs求最短路,再加上考察了一个输出走过的路径



#### 代码

```c++

#include <bits/stdc++.h>
using namespace std;
const int N = 1010;
int a[N][N];
int st[N][N];
pair<int, int> pre[N][N];
vector<pair<int, int>> ans;
int dir[4][2] = {1, 0, -1, 0, 0, 1, 0, -1};
int n;
void bfs(int x, int y)
{
     queue<pair<int, int>> q;
     q.push({x, y});
     st[x][y] = 1;
     while (q.size())
     {
          auto t = q.front();
          q.pop();
          int sx = t.first, sy = t.second;
          for (int i = 0; i < 4; i++)
          {
               int nx = sx + dir[i][0];
               int ny = sy + dir[i][1];
               if (nx < 0 || nx >= n || ny < 0 || ny >= n)
                    continue;
               if (st[nx][ny])
                    continue;
               if (a[nx][ny] == 1)
                    continue;
               pre[nx][ny] = {sx, sy};
               if (nx == n - 1 && ny == n - 1)
                    return;

               q.push({nx, ny});
               st[nx][ny] = 1;
          }
     }
}

int main()
{

     cin >> n;
     for (int i = 0; i < n; i++)
          for (int j = 0; j < n; j++)
               cin >> a[i][j];

     bfs(0, 0);

     int x = n - 1, y = n - 1;
     ans.push_back({n - 1, n - 1});

     while (x != 0 || y != 0)
     {
          int x1, y1; //这里要加一个临时变量,不能直接把值赋给x,y.因为前面x会变,变了后,后面的y的值就不是原来的pre[x][y].second了
          x1 = pre[x][y].first, y1 = pre[x][y].second;
          x = x1, y = y1;
          ans.push_back({x, y});
     }

     reverse(ans.begin(), ans.end());
     for (int i = 0; i < ans.size(); i++)
          cout << ans[i].first << ' ' << ans[i].second << endl;
}

```



```c++

//手写队列,时间快了一倍左右

#include <cstring>
#include <iostream>
#include <algorithm>

#define x first
#define y second

using namespace std;

typedef pair<int, int> PII;

const int N = 1010, M = N * N;

int n;
int g[N][N];
PII q[M];
PII pre[N][N];

void bfs(int sx, int sy)
{
    int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};

    int hh = 0, tt = 0;
    q[0] = {sx, sy};

    memset(pre, -1, sizeof pre);
    pre[sx][sy] = {0, 0};
    while (hh <= tt)
    {
        PII t = q[hh ++ ];

        for (int i = 0; i < 4; i ++ )
        {
            int a = t.x + dx[i], b = t.y + dy[i];
            if (a < 0 || a >= n || b < 0 || b >= n) continue;
            if (g[a][b]) continue;
            if (pre[a][b].x != -1) continue;

            q[ ++ tt] = {a, b};
            pre[a][b] = t;
        }
    }
}

int main()
{
    scanf("%d", &n);

    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < n; j ++ )
            scanf("%d", &g[i][j]);

    bfs(n - 1, n - 1);

    PII end(0, 0);

    while (true)
    {
        printf("%d %d\n", end.x, end.y);
        if (end.x == n - 1 && end.y == n - 1) break;
        end = pre[end.x][end.y];
    }

    return 0;
}

```





### 武士风度的牛



#### 题目



#### 思路

经典bfs求最短路(只不过走法不是向上走一格,向下走一格...),加上了要输出路径长度



#### 代码



```c++
用上一题记录路径的方法,来计算步数

#include <bits/stdc++.h>
using namespace std;
const int N = 160;
char g[N][N];
int st[N][N];
int dir[8][2] = {2, 1, 2, -1, -2, 1, -2, -1, 1, 2, 1, -2, -1, 2, -1, -2};
int n, m;
int step = 0;
pair<int, int> pre[N][N];
void bfs(int x, int y)
{
     queue<pair<int, int>> q;
     q.push({x, y});
     st[x][y] = 1;
     while (q.size())
     {
          auto t = q.front();
          q.pop();
          int sx = t.first, sy = t.second;
          for (int i = 0; i < 8; i++)
          {
               int nx = sx + dir[i][0];
               int ny = sy + dir[i][1];
               if (nx < 0 || nx >= n || ny < 0 || ny >= m)
                    continue;
               if (st[nx][ny])
                    continue;
               if (g[nx][ny] == '*')
                    continue;
               pre[nx][ny] = {sx, sy};
               if (g[nx][ny] == 'H')
                    return;

               q.push({nx, ny});
               st[nx][ny] = 1;
          }
     }
}

int main()
{

     cin >> m >> n;
     int x1, y1, ex, ey;
     for (int i = 0; i < n; i++)
          for (int j = 0; j < m; j++)
          {
               cin >> g[i][j];
               if (g[i][j] == 'K')
                    x1 = i, y1 = j;
               if (g[i][j] == 'H')
                    ex = i, ey = j;
          }
     bfs(x1, y1);

     int x = ex, y = ey;
     while (x != x1 || y != y1)
     {
          int x2, y2;
          x2 = pre[x][y].first, y2 = pre[x][y].second;

          x = x2, y = y2;
          step++;
     }
     cout << step;
}
```



```c++
直接用dist数组存储步数

#include <cstring>
#include <iostream>
#include <algorithm>

#define x first
#define y second

using namespace std;

typedef pair<int, int> PII;

const int N = 155, M = N * N;

int n, m;
char g[N][N];
PII q[M];
int dist[N][N];

int bfs()
{
    int dx[] = {-2, -1, 1, 2, 2, 1, -1, -2};
    int dy[] = {1, 2, 2, 1, -1, -2, -2, -1};

    int sx, sy;
    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < m; j ++ )
            if (g[i][j] == 'K')
                sx = i, sy = j;

    int hh = 0, tt = 0;
    q[0] = {sx, sy};

    memset(dist, -1, sizeof dist);
    dist[sx][sy] = 0;

    while (hh <= tt)
    {
        auto t = q[hh ++ ];

        for (int i = 0; i < 8; i ++ )
        {
            int a = t.x + dx[i], b = t.y + dy[i];
            if (a < 0 || a >= n || b < 0 || b >= m) continue;
            if (g[a][b] == '*') continue;
            if (dist[a][b] != -1) continue;
            if (g[a][b] == 'H') return dist[t.x][t.y] + 1;

            dist[a][b] = dist[t.x][t.y] + 1;
            q[ ++ tt] = {a, b};
        }
    }

    return -1;
}

int main()
{
    cin >> m >> n;

    for (int i = 0; i < n; i ++ ) cin >> g[i];

    cout << bfs() << endl;

    return 0;
}


```





### 抓住那头牛



#### 题目



#### 思路

emm,本题要是没有看标签,可能想不到要用bfs来解,好神奇23333.

和bfs经典求最短路的唯一区别是: 每一个点去往下一个点都有3种可能:+1,-1,*2.而bfs经典求最短路里的每个点可以去往上下左右四个点.我们每讨论一个点,把它从队列里取出来`q.front()`,再把它能走到的其他三个点放入队列,然后`q.pop()`,接着继续取点.

还要用st数组记录一下走过的x值,走过的要是再碰到就不用管了.因为本题输出的是最小花销,先碰到的点绝对比后碰到的花销要小。

其实本来看到一个点有三种可能去处的时候，想到的是dfs，但本题要求的是最短路，就用了bfs。



#### 代码

```c++

#include <bits/stdc++.h>
using namespace std;
const int Max = 1e5 + 10;
int N, K;
int st[Max], dist[Max];
void bfs(int x)
{
     queue<int> q;
     q.push(x);
     st[x] = 1;
     while (q.size())
     {
          int t = q.front();
          q.pop();
          for (int i = 0; i < 3; i++)
          {
               int nx;
               if (i == 0)
                    nx = t + 1;
               if (i == 1)
                    nx = t - 1;
               if (i == 2)
                    nx = t * 2;
               if (st[nx])
                    continue;
               if (nx < 0 || nx > Max)
                    continue;

               dist[nx] = dist[t] + 1;
               if (nx == K)
                    return;

               q.push(nx);
               st[nx] = 1;
          }
     }
}

int main()
{
     cin >> N >> K;
     bfs(N);
     cout << dist[K];
}

```



```c++
或者不用for循环表示三种状态，而是一次就全写出来

#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1e5 + 10;

int n, k;
int q[N];
int dist[N];

int bfs()
{
    memset(dist, -1, sizeof dist);
    dist[n] = 0;
    q[0] = n;

    int hh = 0, tt = 0;

    while (hh <= tt)
    {
        int t = q[hh ++ ];

        if (t == k) return dist[k];

        if (t + 1 < N && dist[t + 1] == -1)
        {
            dist[t + 1] = dist[t] + 1;
            q[ ++ tt] = t + 1;
        }
        if (t - 1 >= 0 && dist[t - 1] == -1)
        {
            dist[t - 1] = dist[t] + 1;
            q[ ++ tt] = t - 1;
        }
        if (t * 2 < N && dist[t * 2] == -1)
        {
            dist[t * 2] = dist[t] + 1;
            q[ ++ tt] = t * 2;
        }
    }

    return -1;
}

int main()
{
    cin >> n >> k;

    cout << bfs() << endl;

    return 0;
}

作者：yxc
```



## 多源BFS

给出n个点，再给一个集合,集合里面包含了这n个点的一部分点,现在要求出这n个点(所有)到这点的集合的最短距离。(最短距离就是假如一个点x，它到集合中每个点的距离是d1,d2,d3,d4……,那么点x到集合的最短距离就是d1,d2,d3这些距离的最小值)



### 矩阵距离

#### 题目



#### 思路

题目大意是矩阵中每一个位置到所有1的最短距离。(所有的1就是上面所说的点的集合)

要是直接用bfs求解，把每个1当作起点，遍历一遍全图，给每个位置附上距离(保留最小)，肯定会超时，因为复杂度是n^4^

多源bfs算法写起来比较简单，和普通bfs的区别就在于要先遍历一遍矩阵，把所有为1的点先存入队列，然后再进行`while(q.size())`。

证明可以结合以下图片和代码进行理解:



![](image/12.png)

如上图这个矩阵，1的位置如图分布，我们先把1都存入队列，然后开始遍历每个1的四周，给其它点附上距离，要是碰到这个点已经有距离了，直接跳过，因为代表肯定有1个1离这个点的距离比你更近！！这样遍历完全图退出bfs，每个点遍历一遍，复杂度是n^2^。



#### 代码

```c++

#include <bits/stdc++.h>
using namespace std;
const int N = 1100;
int dir[4][2] = {0, 1, 1, 0, 0, -1, -1, 0};
char g[N][N];
int st[N][N], dist[N][N];
int n, m;
queue<pair<int, int>> q;

void bfs()
{
     while (q.size())
     {
          auto t = q.front();
          q.pop();
          for (int i = 0; i < 4; i++)
          {
               int x = t.first, y = t.second;
               int nx = x + dir[i][0];
               int ny = y + dir[i][1];
               if (nx < 0 || nx >= n || ny < 0 || ny >= m)
                    continue;
               if (st[nx][ny])
                    continue;
               if (g[nx][ny] == '1')
                    continue;
               dist[nx][ny] = dist[x][y] + 1;
               q.push({nx, ny});
               st[nx][ny] = 1;
          }
     }
}
int main()
{
     cin >> n >> m;
     for (int i = 0; i < n; i++)
          for (int j = 0; j < m; j++)
               cin >> g[i][j];

     for (int i = 0; i < n; i++)
          for (int j = 0; j < m; j++)
          {
               if (g[i][j] == '1')
               {
                    q.push({i, j});
                    st[i][j] = 1;
               }
          }
     bfs();
     for (int i = 0; i < n; i++)
     {
          for (int j = 0; j < m; j++)
          {
               cout << dist[i][j] << ' ';
          }
          cout << endl;
     }
}
```

```c++
手写队列

#include <cstring>
#include <iostream>
#include <algorithm>

#define x first
#define y second

using namespace std;

typedef pair<int, int> PII;

const int N = 1010, M = N * N;

int n, m;
char g[N][N];
PII q[M];
int dist[N][N];

void bfs()
{
    int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};

    memset(dist, -1, sizeof dist);

    int hh = 0, tt = -1;
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= m; j ++ )
            if (g[i][j] == '1')
            {
                dist[i][j] = 0;
                q[ ++ tt] = {i, j};
            }

    while (hh <= tt)
    {
        auto t = q[hh ++ ];

        for (int i = 0; i < 4; i ++ )
        {
            int a = t.x + dx[i], b = t.y + dy[i];
            if (a < 1 || a > n || b < 1 || b > m) continue;
            if (dist[a][b] != -1) continue;

            dist[a][b] = dist[t.x][t.y] + 1;
            q[ ++ tt] = {a, b};
        }
    }
}

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i ++ ) scanf("%s", g[i] + 1);

    bfs();

    for (int i = 1; i <= n; i ++ )
    {
        for (int j = 1; j <= m; j ++ ) printf("%d ", dist[i][j]);
        puts("");
    }

    return 0;
}


```







## 最小步数模型

​	我们之前用的bfs和dfs,都是一张表格或者一块面积,里面一个点在向旁边移动,去求a点到b点的最短路径... 而本题,是整张图的变化,这时我们把整张图当做一个点(把一个棋盘看做一个状态，求从状态a到状态b的最小步数),每变化一次就衍生出另外一个点:最小步数模型.

​	八数码也是最小步数模型题目.

​	这种题一般思路简单,但是用代码表示比较困难,和dp相反.



### 魔板



#### 题目





#### 思路



​	题目所给初始状态是:"12345678",问你要几步能转换到题目所给样例,采用最小步数模型的bfs宽搜:

![](image/13.png)

​	一般都是用哈希表来存储表示每步的状态(map)

​	

​	而关于本题字典序最小的路径问题： 

​	一般来说，输出最字典序最小或者最大的路径不会增加题目的难度和复杂度。出题者因为懒，不搞speci judge，让我们输出唯一的答案，搞了这么一出。
​	做法:我们按照bfs原本的顺序执行操纵，不需要增加多余的代码，就可以实现最小的字典序，只需要每次先搜索字典序最小的操作就行(本题先用A操作,再B操作,最后C操作).



​	输出路径:

```c++
while (end != Start)	
     {
          res += pre[end].first;
          end = pre[end].second;
     }
```



​	但这个时间复杂度是多少呢?



#### 代码

```c++
#include <bits/stdc++.h>
using namespace std;
char g[2][4];
unordered_map<string, pair<char, string>> pre;//存储string的状态前驱:chars:上一步操作,string:上一步的状态
unordered_map<string, int> dist;//存储到达这个string的花费

void Set(string state)//字符串恢复成2*4矩阵
{
     for (int i = 0; i < 4; i++)
          g[0][i] = state[i];
     for (int i = 7, j = 0; j < 4; i--, j++)
          g[1][j] = state[i];
}

string get()	//矩阵->字符串
{
     string res;
     for (int i = 0; i < 4; i++)
          res += g[0][i];
     for (int i = 3; i >= 0; i--)
          res += g[1][i];
     return res;
}

string move0(string state)
{
     Set(state);
     for (int i = 0; i < 4; i++)
          swap(g[0][i], g[1][i]);
     return get();
}

string move1(string state)
{
     Set(state);
     int v0 = g[0][3], v1 = g[1][3];
     for (int i = 3; i >= 0; i--)
     {
          g[0][i] = g[0][i - 1];
          g[1][i] = g[1][i - 1];
     }
     g[0][0] = v0, g[1][0] = v1;
     return get();
}

string move2(string state)
{
     Set(state);
     int v = g[0][1];
     g[0][1] = g[1][1];
     g[1][1] = g[1][2];
     g[1][2] = g[0][2];
     g[0][2] = v;
     return get();
}

int bfs(string Start, string end)//bfs
{
     if (Start == end)
          return 0;

     queue<string> q;
     q.push(Start);
     dist[Start] = 0;

     while (!q.empty())
     {
          auto t = q.front();
          q.pop();

          string m[3];
          m[0] = move0(t);
          m[1] = move1(t);
          m[2] = move2(t);

          for (int i = 0; i < 3; i++)
               if (!dist.count(m[i]))	//去重
               {
                    dist[m[i]] = dist[t] + 1;
                    pre[m[i]] = {'A' + i, t};
                    q.push(m[i]);
                    if (m[i] == end)
                         return dist[end];
               }
     }

     return -1;
}

int main()
{
     string Start, end;
     for (int i = 0; i < 8; i++)
     {
          char x;
          cin >>
              x;
          end += x;
     }
     Start = "12345678";

     int step = bfs(Start, end);

     cout << step << endl;

     string res;
     while (end != Start)	//输出路径
     {
          res += pre[end].first;
          end = pre[end].second;
     }

     reverse(res.begin(), res.end());

     if (step > 0)
          cout << res << endl;

     return 0;
}

```







## 双端队列广搜



### 电路维修



#### 思路

​	本题题意是:能把每一个格子的线段旋转位置,问你最少旋转几次,能让起点到达终点(像之前玩的小游戏)

​	把题目意思转换一下,假如0,0(起点)能直接走到1,1,那么我们就把这段路抽象成一条边权为0的边,要是必须旋转一下才能走到1,1,那么这段路就抽象成一条边权为1的边,现在就等于问你,从起点走到终点,最小花费是多少.

​	这道题可以采用dij来写(可能会超时),也可以采用双端队列bfs来写,双端队列bfs就是处理这种边权只为0和1的题目,它和普通bfs的区别就在于,当你边权为0,存对头里,边权为1,存队尾里,一般bfs求最短路只能求解边权一样的情况.(双端队列其实就是dij特殊情况,复杂度低一点)

​	这道题其实就是dijkstra算法的特殊情况。(因为本题的边权只有0和1两种).然后，dijkstra的流程，就是先把源点放入优先队列，接下来重复以下操作(取出队列中距离源点最近的点—优先队列的队头，用该点更新其它与该点相邻的点的距离，再把更新后的距离放入队列)。
​	每个点在出队的时候就说明从源点到该点的最短距离已经找到，因此要对这个点进行标记，后续计算时忽略该点。

​	本题也是一样，先把左上方的(0，0)点放入队列中，然后接着操作。
​	但是本题用的数据结构并不是优先队列，而是双端队列，为了实现和优先队列相同的效果，当边权重是零的时候，就把新的点从队列头插入，是一的时候，就从队列尾部插入。这样可以保证该队列从头部到尾部，是单调不下降的。这样，就从本质上实现了dijkstra算法。![](image/15.png)

​	

​	y总在视频里用两段性和单调性证明了为什么bfs可求最短路.





​	细节:

本题有两个位置偏移量,可能不大好理解:

![](image/14.png)

`int dir1[4][2] = {-1, -1, -1, 1, 1, 1, 1, -1};`

这就是正常的假如你此时在(1,2)(蓝色字迹),可以前往(0,1),(0,3),(2,1),(2,3)四个点

`int dir2[4][2] = {-1, -1, -1, 0, 0, 0, 0, -1};`

这是用来表示此时电线的状态,假如你要从1,2走到0,3.那么格子的电线必须是'/'才行,这时候我们就需要判断给你的字符二维数组里的这个位置是不是也是'/'.而从1,2走到0,3所要走的电线对应在字符数组里的位置就是(0,2)(红笔标注),所以`(a[ix][iy] 是否等于 c[i])	,` `char c[] = "\\/\\/";`c数组存储的是理想状态,a就是现实状态,判断他们是否相等来得到是否要旋转电线.



#### 代码

时间复杂度 O(nm)

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 500 + 10;
char a[N][N];
int n, m;
char c[] = "\\/\\/";
int dir1[4][2] = {-1, -1, -1, 1, 1, 1, 1, -1};
int dir2[4][2] = {-1, -1, -1, 0, 0, 0, 0, -1};
int dis[N][N];
int main()
{
     int t;
     cin >> t;
     while (t--)
     {

          cin >> n >> m;
          for (int i = 0; i < n; i++)
               for (int j = 0; j < m; j++)
               {
                    cin >> a[i][j];
               }
          memset(dis, 0x3f, sizeof dis);
          deque<pair<int, int>> q;
          q.push_front({0, 0});
          dis[0][0] = 0;
          while (q.size())
          {
               auto t = q.front();
               q.pop_front();
               for (int i = 0; i < 4; i++)
               {
                    int nx = t.first + dir1[i][0], ny = t.second + dir1[i][1];
                    if (nx < 0 || nx > n || ny < 0 || ny > m)
                         continue;
                    int ix = t.first + dir2[i][0], iy = t.second + dir2[i][1];
                    int d = dis[t.first][t.second] + (a[ix][iy] != c[i]); //(a[ix][iy] != c[i])判断走这一步要不要旋转电线

                    if (d < dis[nx][ny])
                    {
                         dis[nx][ny] = d;
                         if (a[ix][iy] == c[i])
                              q.push_front({nx, ny});
                         else
                              q.push_back({nx, ny});
                    }
               }
          }
          if (dis[n][m] == 0x3f3f3f3f)
               puts("NO SOLUTION");
          else
               cout << dis[n][m] << endl;//最后还是输出d[n][m],虽然我们初始是[0,n)来存取数组,但那是代表格子的位置,真实的起点是(0,0),终点是(n,m)
     }
}
```

​	

```c++
//y总
//大致一样,但其实不用判重,由于距离变小才能进入队列，因此之前的点不会进入再次队列中
#include <cstring>
#include <iostream>
#include <algorithm>
#include <deque>

#define x first
#define y second

using namespace std;

typedef pair<int, int> PII;

const int N = 510, M = N * N;

int n, m;
char g[N][N];
int dist[N][N];
bool st[N][N];

int bfs()
{
    memset(dist, 0x3f, sizeof dist);
    memset(st, 0, sizeof st);
    dist[0][0] = 0;
    deque<PII> q;
    q.push_back({0, 0});

    char cs[] = "\\/\\/";
    int dx[4] = {-1, -1, 1, 1}, dy[4] = {-1, 1, 1, -1};
    int ix[4] = {-1, -1, 0, 0}, iy[4] = {-1, 0, 0, -1};

    while (q.size())
    {
        PII t = q.front();
        q.pop_front();

        if (st[t.x][t.y]) continue;
        st[t.x][t.y] = true;

        for (int i = 0; i < 4; i ++ )
        {
            int a = t.x + dx[i], b = t.y + dy[i];
            if (a < 0 || a > n || b < 0 || b > m) continue;

            int ca = t.x + ix[i], cb = t.y + iy[i];
            int d = dist[t.x][t.y] + (g[ca][cb] != cs[i]);

            if (d < dist[a][b])
            {
                dist[a][b] = d;

                if (g[ca][cb] != cs[i]) q.push_back({a, b});
                else q.push_front({a, b});
            }
        }
    }

    return dist[n][m];
}

int main()
{
    int T;
    scanf("%d", &T);
    while (T -- )
    {
        scanf("%d%d", &n, &m);
        for (int i = 0; i < n; i ++ ) scanf("%s", g[i]);

        int t = bfs();

        if (t == 0x3f3f3f3f) puts("NO SOLUTION");
        else printf("%d\n", t);
    }

    return 0;
}

```





## 双向广搜

​	用来求最短路，是普通BFS求最短路模型的优化，通过每次向不同的方向扩展(一个是从起点往终点搜，还有一个是从终点向起点搜，如果两个队列中有相同的则说明走通)，让搜索空间缩小，提高搜索效率



### 字串变换



#### 思路

(BFS,双向BFS) O((LN)^5^)
	假如有K次变化方式，那么如果直接BFS，最坏情况下的搜索空间是 K^10^(每次k个)，非常大，所以会TLE或者MLE。

![](image/16.png)

​	如果采用双向BFS，则可以把搜索空间降到 2K^5^。在实际测试中只需 20ms 左右，剪枝效果很好。

​	扩展(子串变换)方式是：分别枚举在原字符串中使用替换规则的起点，和所使用的的替换规则,每一次扩展要把一层(队列里的所有字符串)都扩展开

​	时间复杂度
​	假设字符串长度是 L，替换规则一共有 N 个，则：

​	在最坏情况下每次会从字符串的每个位置开始，使用全部的 N 种替换规则，因此总共会有 LN 种扩展方式，从起点和终点最多会分别扩展5步，因此总搜索空间是 2(LN)^5^。

​	在BFS过程中，空间中的每个状态只会被遍历一次，因此时间复杂度是 O((LN)^5^)。





#### 代码

```c++
#include <iostream>
#include <cstring>
#include <algorithm>
#include <queue>
#include <unordered_map>

using namespace std;

const int N = 6;

int n;
string A, B;
string a[N], b[N];

int extend(queue<string> &q, unordered_map<string, int> &da, unordered_map<string, int> &db,
           string a[N], string b[N])
{
     int d = da[q.front()];
     while (q.size() && da[q.front()] == d) //一次扩展就要扩展一层,把队列里现有的字符串的都扩展一遍
     {
          auto t = q.front();
          q.pop();

          for (int i = 0; i < n; i++)             //枚举所有变换状态
               for (int j = 0; j < t.size(); j++) //使用第i种替换状态对字符串进行替换
                    if (t.substr(j, a[i].size()) == a[i])
                    {
                         string r = t.substr(0, j) + b[i] + t.substr(j + a[i].size());
                         if (db.count(r))               //要是qb里有,代表找到了
                              return da[t] + db[r] + 1; //输出花费(距离和)
                         if (da.count(r))
                              continue;
                         da[r] = da[t] + 1;
                         q.push(r);
                    }
     }

     return 11;
}

int bfs()
{
     if (A == B)
          return 0;
     queue<string> qa, qb;//定义队列,存储A/B扩展出的某一层的所有字符串
     unordered_map<string, int> da, db; //定义距离

     qa.push(A), qb.push(B);//初始就是A和B
     da[A] = db[B] = 0;

     int step = 0;
     while (qa.size() && qb.size())
     {
          int t;
          if (qa.size() < qb.size())         //哪个短就先扩展哪个,稍微节约时间
               t = extend(qa, da, db, a, b); //一次扩展,对队列里的每个字符串都进行变换操作
          else
               t = extend(qb, db, da, b, a); //一次扩展

          if (t <= 10)
               return t;
          if (++step == 10) //扩展了10步还没有找到解,输出-1
               return -1;
     }

     return -1;
}

int main()
{
     cin >> A >> B;
     while (cin >> a[n] >> b[n]) //题目没告诉你如何终止
          n++;

     int t = bfs();
     if (t == -1)
          puts("NO ANSWER!");
     else
          cout << t << endl;

     return 0;
}

```





## A*

​	和dij长得类似

​	为启发式算法，可以看成是堆优化版dijkstra算法的升级，增添了一个估价函数(这个估价函数的值应该小于等于真实值)，通过将现在已经走过的路程和估价函数相加，利用最小堆即可实现,而堆优化版的dijkstra算法可以看成是估价函数为0的A*算法







## DFS之连通性模型



### 迷宫





#### 思路



​	本题较为简单,dfs模板题(bfs也可以写). 

​	只要判断能不能走到终点就可以,不用输出花费

​	不回溯

​	dfs返回值:bool

​	时间复杂度是o(n^2^)么,每个点只走一次



#### 代码

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 110;
char a[N][N];
int n;
int dir[4][2] = {1, 0, -1, 0, 0, 1, 0, -1};
int st[N][N];
int sx, sy, ex, ey;
bool dfs(int x, int y) //返回bool类型
{
     if (x == ex && y == ey)
          return 1;
     st[x][y] = 1; //防止走之前走过的路(点),陷入循环
     for (int i = 0; i < 4; i++)
     {
          int nx = x + dir[i][0], ny = dir[i][1] + y;
          if (nx < 0 || nx >= n || ny < 0 || ny >= n)
               continue;
          if (a[nx][ny] == '#' || st[nx][ny] == 1)
               continue;
         
          st[nx][ny] = 1;
          if (dfs(nx, ny))
               return 1;
     }
     return 0;
}

int main()
{
     int t;
     cin >> t;
     while (t--)
     {
          cin >> n;
          for (int i = 0; i < n; i++)
               for (int j = 0; j < n; j++)
                    cin >> a[i][j];
          memset(st, 0, sizeof st);
          cin >> sx >> sy >> ex >> ey;

          if (a[sx][sy] == '#' || a[ex][ey] == '#')
               cout << "NO" << endl;
          else
          {
               if (dfs(sx, sy))
                    cout << "YES" << endl;
               else
                    cout << "NO" << endl;
          }
     }
}

```













### 红与黑



#### 思路

​	与上题类似,注意输入格式







#### 代码

```c++
#include <bits/stdc++.h>
#include <bits/stdc++.h>
using namespace std;
const int N = 110;
char a[N][N];
int n, m;
int dir[4][2] = {1, 0, -1, 0, 0, 1, 0, -1};
int st[N][N];
int sx, sy, ex, ey;
int Sum = 1;
void dfs(int x, int y) //返回bool类型
{
     st[x][y] = 1; //防止走之前走过的路(点),陷入循环
     for (int i = 0; i < 4; i++)
     {
          int nx = x + dir[i][0], ny = dir[i][1] + y;
          if (nx < 0 || nx >= n || ny < 0 || ny >= m)
               continue;
          if (a[nx][ny] == '#' || st[nx][ny] == 1)
               continue;

          st[nx][ny] = 1;
          Sum++;
          dfs(nx, ny);
     }
     return;
}

int main()
{

     while (cin >> m >> n, m || n)
     {
          for (int i = 0; i < n; i++)
               for (int j = 0; j < m; j++)
                    cin >> a[i][j];
          for (int i = 0; i < n; i++)
               for (int j = 0; j < m; j++)
               {
                    if (a[i][j] == '@')
                         sx = i, sy = j;
               }
          memset(st, 0, sizeof st);

          dfs(sx, sy);
          cout << Sum << endl;
          Sum = 1;
     }
}

```









## DFS之搜索顺序



### 马走日

题目

马在中国象棋以日字形规则移动。

请编写一段程序，给定 n∗m 大小的棋盘，以及马的初始位置 (x，y)，要求不能重复经过棋盘上的同一个点，计算马可以有多少途径遍历棋盘上的所有点。



输入格式

第一行为整数 T，表示测试数据组数。

每一组测试数据包含一行，为四个整数，分别为棋盘的大小以及初始位置坐标 n,m,x,y。

输出格式

每组测试数据包含一行，为一个整数，表示马能遍历棋盘的途径总数，若无法遍历棋盘上的所有点则输出 0。



数据范围

1≤T≤9,1≤m,n≤9,
0≤x≤n−1,0≤y≤m−1



输入样例：

```
1
5 4 0 0
```

输出样例：

```
32
```





#### 思路

dfs模板题,请注意回溯的细节

本题要回溯,并且因为是讨论所有路线,所以题目所给数据较小,但也运行了很长时间:三千ms





#### 代码

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 10;
int dir[8][2] = {2, 1, 2, -1, -2, 1, -2, -1, 1, -2, 1, 2, -1, 2, -1, -2};
int n, m, sx, sy;
int st[N][N];
int Sum = 0;
void dfs(int x, int y, int num)
{
     //如果这里加上st[x][y]=1,则最后也要把它回溯成0
     if (num == n * m)
     {
          Sum++;
          return;
     }

     for (int i = 0; i < 8; i++)
     {
          int nx = x + dir[i][0], ny = dir[i][1] + y;
          if (nx < 0 || nx >= n || ny < 0 || ny >= m)
               continue;
          if (st[nx][ny])
               continue;
          st[nx][ny] = 1;
          dfs(nx, ny, num + 1); //必须num+1,不能++
          st[nx][ny] = 0;       //回溯,当运行到这一句的时候,代表一条路线讨论完了(可能走通,可能没走通)
     }
}
int main()
{
     int t;
     cin >> t;
     while (t--)
     {
          cin >> n >> m >> sx >> sy;
          memset(st, 0, sizeof st);
          st[sx][sy] = 1; //这句不能忘
          dfs(sx, sy, 1);
          cout << Sum << endl;
          Sum = 0;
     }
}
```









### 单词接龙









### 分成互质组





#### 思路

​	本题数据量较小,采用爆搜的方法,搜索出所有的分组方案,选取组数最小的方案数(剪枝),np完全问题.

​	本题搜索方法之前没遇过,这个搜索方法目的是使得分的组数尽可能少

​	方法:

​	分支方法:第一个数放在第一组,然后取下一个数,先判断它能不能放入之前存在的组(第一组..),行的话在这就可以进行一次dfs,进行深度讨论(分支):1:把这个数放入第一组,取第三个数,2:给第二个数新开一组,把它放入新一组里...

![](image/17.png)





#### 代码

```c++
//和y总代码有点不同,我这写法与下一题小猫爬山雷同
//小数据,直接爆搜
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

const int N = 15;
vector<int> g[N];
int nums[N];
int ans = N;
int n;

int gcd(int a, int b)
{
     return b ? gcd(b, a % b) : a;
}

bool check(vector<int> &vec, int x) //检测这个数和这个组是否互质
{
     for (int i = 0; i < vec.size(); i++)
          if (gcd(vec[i], x) > 1)
               return false;
     return true;
}


// u是当前处理到序列的下标，used是目前使用到的组数
void dfs(int u, int used)
{
     // 剪枝：如果当前使用的组已经>=目前获得的最优解，停止当前分支的搜索
     if (used >= ans)
          return;

     if (u >= n)
     {
          ans = min(ans, used + 1);
          return;
     }

    
     // 先在已经使用的组里面找，看看能不能插进去,但即使能不能插的进去都要再试着放入新的组里找,可能虽然这两个个数互质,但把他们放一起并非最佳方案
     for (int i = 0; i <= used; i++)
     {
          if (check(g[i], nums[u]))
          {
               g[i].push_back(nums[u]);
               dfs(u + 1, used);
               g[i].pop_back(); //回溯
          }
     }

	//放入新的组    
     // 剪枝：因为n个数最多只放进n个组，所以只要总组数<=n，允许尝试放进新的组
     if (used + 1 <= n)
     {
          g[used + 1].push_back(nums[u]);
          dfs(u + 1, used + 1);
          g[used + 1].pop_back();//回溯
     }
}

int main()
{
     scanf("%d", &n);

     for (int i = 0; i < n; i++)
          scanf("%d", &nums[i]);

     // 初始处理nums[0], 初始放入g[0]
     dfs(0, 0);

     printf("%d\n", ans);

     return 0;
}

```











## DFS之剪枝与优化



### 小猫爬山





#### 思路

​	与互质数那题雷同

​	难点在于选择正确的搜索顺序(方法)





#### 代码

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 20;
int a[N], g[N];
int u = 0x3f3f3f3f;
int n, w;
vector<int> v[N];

void dfs(int idx, int used)
{
     //剪枝
     //要是现在的缆车使用量以及大于之前算出的答案的缆车数量,直接退出
     if (used >= u)
          return;

     //赋值
     if (idx == n + 1)
     {
          u = min(used, u);
          return;
     }

     //看看第idx只猫能不能插入之前的缆车
     for (int i = 0; i <= used; i++)
     {
          if (g[i] + a[idx] <= w)
          {
               g[i] += a[idx];
               dfs(idx + 1, used);
               g[i] -= a[idx];
          }
     }

     //把第idx只猫放入新的缆车,无论它能不能插入前面的缆车,这步都要进行,因为要搜索出所有组合方案
     if (used + 1 <= u)
     {
          g[used + 1] += a[idx];
          dfs(idx + 1, used + 1);
          g[used + 1] -= a[idx];
     }
}

int main()
{
     cin >> n >> w;
     for (int i = 0; i < n; i++)
          cin >> a[i];

     dfs(0, 0);
     cout << u+1 << endl;
}
```









### 数独







