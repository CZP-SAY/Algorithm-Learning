[Dashboard - Codeforces Round #806 (Div. 4) - Codeforces](https://codeforces.com/contest/1703)

## D

**题意**

​	给你n个字符串,让你输出第i个字符串能否由第k个和第t个字符串拼接而成,k可以等于t,每个字符串长度最多为8。

**思路**

​	一道简单的stl题，之前没注意到长度为8这个条件.....把每个字符串储存在map里,然后遍历i,对s[i]串进行分割,看看前后两个字符串存不存在就可以了

**code**

```c++
#include <bits/stdc++.h>
using namespace std;
const int maxn = 1e5 + 5;
int n, T, tot, flag;
string s[maxn];
map<string, int> mp;
int main()
{
     ios::sync_with_stdio(0);
     cin >> T;
     while (T--)
     {
          cin >> n;
          tot = 0;
          for (int i = 1; i <= n; i++)
               cin >> s[i], mp[s[i]] = ++tot;
          for (int i = 1; i <= n; i++)
          {
               flag = 0;
               for (int j = 1; j <= s[i].size(); j++)
                    if (mp[s[i].substr(0, j)] && mp[s[i].substr(j, s[i].size() - j)])
                    {
                         flag = 1;
                         break;
                    }
               cout << flag;
          }
          cout << endl;
          for (int i = 1; i <= n; i++)
               mp[s[i]] = 0;
     }
     return 0;
}
```





## E

**题意**

​	给你n个矩形，矩形内部由0/1填充，将矩形旋转90度，旋转四次(直到变回原位)，现在你的一次操作可以让矩形里的一个0变成1或1变成0，问你旋转的这四次产生的矩形，你至少要几次操作才能让他们四个都相等

​	n<=100,矩形边长<=100

**思路**

​	想要一个矩阵旋转0,90,180,270度时完全相同，只需要让其**中心对称**即可

​	显然一个点旋转后将会经过四个点，我们只需要让这四个点相同即可，假设这四个点的值的和为t，则将它们变为相同的值需要的最小次数为 （）min（t,4−t）

​	接下来我们需要知道这四个点到底是哪几个点，这只需要一个点旋转90度的时候坐标怎么变即可
​	假设现在有一个点 （）（x,y） 想要绕中心旋转90度（注意x代表行，y代表列），那么新的坐标 （xx,yy） 将会满足 xx=y，yy=n+1−x （自己画一个验证一下就知道了）



**code**

​	

```c++
#include <bits/stdc++.h>
using namespace std;
#define il inline
#define reg register
il int read()
{
     reg int x = 0, f = 1;
     reg char c = getchar();
     while (c < '0' || c > '9')
     {
          if (c == '-')
               f = -1;
          c = getchar();
     }
     while (c >= '0' && c <= '9')
          x = x * 10 + c - 48, c = getchar();
     return x * f;
}
const int maxn = 105, inf = 1e9 + 7;
int n, T, t, ans = 0, a[maxn][maxn], x, y, xx, yy;
bool ins[maxn][maxn];
string s;
int main()
{
     T = read();
     while (T--)
     {
          n = read();
          ans = 0;
          for (int i = 1; i <= n; i++)
          {
               cin >> s;
               for (int j = 0; j < n; j++)
                    a[i][j + 1] = (s[j] == '1'), ins[i][j + 1] = 0;
          }
          for (int i = 1; i <= n; i++)
               for (int j = 1; j <= n; j++)
               {
                    if (n & 1 && i == (n + 1) / 2 && j == (n + 1) / 2)
                         continue; // n为奇数时存在中心，不需要变动
                    if (!ins[i][j])
                    {
                         t = 0;
                         x = i, y = j;
                         while (!ins[x][y])
                         {
                              ins[x][y] = 1, t += a[x][y];
                              xx = y, yy = n + 1 - x; //变为旋转90度后的下一个点
                              x = xx, y = yy;
                         }
                         ans += min(t, 4 - t);
                    }
               }
          cout << ans << endl;
     }
     return 0;
}
```





## F









## G