https://codeforces.com/contest/1734



## A

**题意:**

​	从n个长度为a[i]木棍中找到三个木棍组成一个等腰三角形，修改一个木棍1长度的代价为1，求最小代价。

**思路:**

​	先给所有的木棍排序，暴力枚举出差值最小的连续三个木棍就可以了

**code**

```
    #include <bits/stdc++.h>
    using namespace std;
    #define int long long
    const int N = 300 + 10;
    int a[N];
    signed main()
    {
         int t;
         cin >> t;
         while (t--)
         {
              int n;
              cin >> n;
              for (int i = 0; i < n; i++)
                   cin >> a[i];
              int sum = 0;
              sort(a, a + n);
              sum = a[1] - a[0] + a[2] - a[1];
              for (int i = 1; i + 2 < n; i++)
              {
                   if(a[i+1]-a[i]+a[i+2]-a[i+1]<=sum)
                        sum = a[i + 1] - a[i] + a[i + 2] - a[i + 1];
              }
              cout<<sum<<'\n';
         }
    }
```





## B

**题意:**

​	给定一个三角形的金字塔，点亮一部分的砖块，使得每一层的砖块的亮度等于当前层(从高往低)，请构造出一种解使得金字塔满足要求。一个点亮的砖块可以将光传递到下面两个砖块中，一个砖块的亮度为所有能够传递光的砖的数量。

**思路:**

​	我们找规律可以发现，只需要让最两侧，也就是金字塔的最外一层点亮，即可让所有砖块的亮度等于当前层数。

**code**

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1e6 + 10;
typedef long long ll;

int main()
{
     ios::sync_with_stdio(0), cin.tie(0);
     int t;
     cin >> t;
     while (t--)
     {
          int n;
          cin >> n;
          for (int i = 1; i <= n; i++)
          {
               if (i == 1)
               {
                    cout << 1 << endl;
                    continue;
               }
               cout << 1 << " ";
               for (int j = 1; j <= i - 2; j++)
                    cout << 0 << " ";
               cout << 1 << endl;
          }
     }
}
```

